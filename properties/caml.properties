#	Define SciTE settings for Objective Caml, Standard ML 97 files
#
#	To use with Standard ML source in .ml files, select Standard ML
#	from the SciTE Language menu (or adjust the properties below).
#
# To fully enable this Scintilla lexer, make sure the following entries
#	are present and uncommented in your SciTE properties:
#
#		$(filter.caml)\
#		$(filter.sml)\
#
#		Objective Caml|ml||\
#		Standard ML|sml||\
#
#		import caml

# OCaml/SML implementation and interface files
file.patterns.caml=*.ml;*.mli
file.patterns.sml=*.sml;*.mlb;*.sig
file.patterns.fs=*.fsx;*.fs;*.fsi;*.fsscript

filter.caml=Objective Caml (ml mli)|$(file.patterns.caml)|
filter.sml=Standard ML 97 (sml ml)|$(file.patterns.sml)|
filter.fs=F# (fsx fsscript fs fsi)|$(file.patterns.fs)|

lexer.*.caml=caml
lexer.$(file.patterns.caml)=caml
lexer.$(file.patterns.sml)=caml
lexer.$(file.patterns.fs)=caml

# the line below is ONLY used as part of "external" lexer support
#lexerpath.$(file.patterns.caml)=LexCaml.dll
#lexerpath.$(file.patterns.sml)=LexCaml.dll

# the standard Objective Caml 3.09/3.10/3.11 language "textual" keywords
keywordstandard.caml= \
and as assert asr begin class \
constraint do done downto else end \
exception external false for fun function \
functor if in include inherit initializer \
land lazy let lor lsl lsr \
lxor match method mod module mutable \
new object of open or private \
rec sig struct then to true \
try type val virtual when while \
with
keywords.$(file.patterns.caml)=$(keywordstandard.caml)

# the standard Standard ML '97 language "textual" keywords
keywordstandard.sml= \
abstype andalso and as case datatype div do \
else end eqtype exception \
false fn fun functor handle if infixr infix include in let local \
mod nonfix not of open op orelse raise rec \
sharing signature sig structure struct then true type use \
val while withtype with
keywords.$(file.patterns.sml)=$(keywordstandard.sml)

# the standard F# language "textual" keywords
keywordclass.fs=abstract and as assert base begin class default delegate do done downcast downto elif else end exception extern false finally for fun function global if in inherit inline interface internal lazy let let! match member module mutable namespace new not null of open or override private public rec return return! select static struct then to true try type upcast use use! val void when while with yield yield!
keywords.$(file.patterns.fs)=$(keywordclass.fs)

# "optional" Objective Caml / library keywords; some suggested entries are here,
# more could come from, say, Pervasives ('parser' is from Camlp4)
keywordoptional1.caml= \
option Some None ignore ref lnot succ pred parser
keywords2.$(file.patterns.caml)=$(keywordoptional1.caml)

# "optional" Standard ML '97 / library keywords; some suggested entries are here,
# more could come from, say, Standard Basis Library
keywordoptional1.sml= \
option SOME NONE ignore ref \
chr explode implode ord size
keywords2.$(file.patterns.sml)=$(keywordoptional1.sml)

# "optional" Objective Caml / library keywords; some suggested entries are here,
# more could come from, say, user-defined types
keywordoptional2.caml= \
array bool char float int list string unit
keywords3.$(file.patterns.caml)=$(keywordoptional2.caml)

# "optional" Standard ML '97 / library keywords; some suggested entries are here,
# more could come from, say, user-defined types
keywordoptional2.sml= \
array bool char int list nil real string unit vector word
keywords3.$(file.patterns.sml)=$(keywordoptional2.sml)

word.characters.$(file.patterns.caml)=$(chars.alpha)$(chars.numeric)_'`
word.characters.$(file.patterns.sml)=$(chars.alpha)$(chars.numeric)_'

comment.stream.start.caml=(*
comment.stream.end.caml=*)
comment.box.start.caml=(*
comment.box.middle.caml= *
comment.box.end.caml= *)

# "folding" support not currently implemented

# "Out-of-the-box" syntax colors are defined here - I like having
# my literals (number, char, and string), tag-names, and "optional"
# keywords stand out - you might not, so adjust accordingly!
# Default
style.caml.32=$(font.base)
# White space
style.caml.0=fore:#7F7F7F
# Identifiers
style.caml.1=
# Tag-names
#style.caml.2=
style.caml.2=fore:#FFFFFF,back:#001F00
# Keywords (builtin language-defined keywords)
style.caml.3=$(colour.keyword),bold
# Keywords2 (season to taste - use for option, Some, None, etc)
#style.caml.4=
style.caml.4=fore:#FFFFFF,back:#1F1F00
# Keywords3 (season to taste - use for bool, char, float, etc)
#style.caml.5=
#style.caml.5=fore:#FFFFFF,back:#001F1F
style.caml.5=fore:#a0000,bold
# Linenum directive
style.caml.6=back:#3F3F3F,$(font.base)
# Operators
style.caml.7=$(colour.operator),bold
# Number
#style.caml.8=$(colour.number)
style.caml.8=fore:#FFFFFF,back:#0000FF
# Single quoted string (character constant)
#style.caml.9=$(colour.char)
style.caml.9=fore:#FFFFFF,back:#0000FF
# Embedded whitespace (SML character/string constant)
#style.caml.10=
style.caml.10=fore:#FFFFFF,back:#1F1F1F
# Double quoted string (string constant)
#style.caml.11=$(colour.string)
style.caml.11=fore:#FFFFFF,back:#0000FF
# Comment (NOT nested)
style.caml.12=$(colour.code.comment.box),$(font.code.comment.box)
# Comment (SINGLY nested)
#style.caml.13=$(colour.code.comment.box),$(font.code.comment.box)
style.caml.13=$(colour.embedded.comment),$(font.code.comment.box)
# Comment (DOUBLY nested)
#style.caml.14=$(colour.code.comment.box),$(font.code.comment.box)
style.caml.14=$(colour.embedded.comment),$(font.code.comment.box)
# Comment (TRIPLY nested)
#style.caml.15=$(colour.code.comment.box),$(font.code.comment.box)
style.caml.15=$(colour.embedded.comment),$(font.code.comment.box)

# Braces are only matched in operator style
braces.caml.style=7

# The below command(s) can and should be adjusted to reflect your environment;
# in addition, per-directory overrides are possible, so that project-specific "build"
# commands may be used for more complex cases - see the SciTE documentation.
command.compile.$(file.patterns.caml)=ocamlc -c $(FileNameExt)
